##
# @file plotter.py
# @package openmoc.plotter
# @brief The plotter module provides utility functions to plot data from
#        OpenMOCs C++ classes, in particular, the geomery, including Material,
#        Cells and flat source regions, and fluxes and pin powers.
# @author William Boyd (wboyd@mit.edu)
# @date December 14, 2015

import os
import sys
import numpy as np
import numpy.random
import matplotlib
from mpl_toolkits.mplot3d import Axes3D

# force headless backend, or set 'backend' to 'Agg'
# in your ~/.matplotlib/matplotlibrc
matplotlib.use('Agg')

import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib.cm as cmx

import openmoc

# For Python 2.X.X
if (sys.version_info[0] == 2):
    from log import *
    from process import *
# For Python 3.X.X
else:
    from openmoc.log import *
    from openmoc.process import *

# Force non-interactive mode, or set 'interactive' to False
# in your ~/.matplotlib/matplotlibrc
plt.ioff()

## Default matplotlib parameters to use in all plots
matplotlib_rcparams = matplotlib.rcParamsDefault
matplotlib_rcparams['font.family'] = 'sans-serif'
matplotlib_rcparams['font.weight'] = 'normal'
matplotlib_rcparams['font.size'] = 15
matplotlib_rcparams['savefig.dpi'] = 500
matplotlib_rcparams['figure.dpi'] = 500

## A static variable for the output directory in which to save plots
subdirectory = "/plots/"

TINY_MOVE = openmoc.TINY_MOVE


##
# @brief Plots the characteristic tracks from an OpenMOC simulation.
# @details This method requires that Tracks have been generated by a
#          TrackGenerator object. A user may invoke this function from
#          an OpenMOC Python file as follows:
#
# @code
#         openmoc.plotter.plot_tracks(track_generator)
# @endcode
#
# @param track_generator the TrackGenerator which has generated Tracks
# @param get_figure whether or not to return the Matplotlib figure
def plot_tracks(track_generator, get_figure=False):

    global subdirectory, matplotlib_rcparams
    directory = openmoc.get_output_directory() + subdirectory

    # Ensure that normal settings are used even if called from ipython
    curr_rc = dict(matplotlib.rcParams)
    matplotlib.rcParams.update(matplotlib_rcparams)

    # Make directory if it does not exist
    if not os.path.exists(directory):
        os.makedirs(directory)

    # Error checking
    if 'TrackGenerator' not in str(type(track_generator)):
        py_printf('ERROR', 'Unable to plot Tracks since from %s rather ' +
                  'than a TrackGenerator', str(type(track_generator)))

    if not track_generator.containsTracks():
        py_printf('ERROR', 'Unable to plot Tracks since the track ' +
                  'generator has not yet generated tracks')

    py_printf('NORMAL', 'Plotting the tracks...')

    # Retrieve data from TrackGenerator
    vals_per_track = openmoc.NUM_VALUES_PER_RETRIEVED_TRACK
    num_azim = track_generator.getNumAzim()
    spacing = track_generator.getTrackSpacing()
    num_tracks = track_generator.getNumTracks()
    coords = track_generator.retrieveTrackCoords(num_tracks*vals_per_track)

    # Convert data to NumPy arrays
    coords = np.array(coords)
    x = coords[0::vals_per_track/2]
    y = coords[1::vals_per_track/2]

    # Make figure of line segments for each Track
    fig = plt.figure()
    fig.patch.set_facecolor('none')
    for i in range(num_tracks):
        plt.plot([x[i*2], x[i*2+1]], [y[i*2], y[i*2+1]], 'b-')

    plt.xlim([x.min(), x.max()])
    plt.ylim([y.min(), y.max()])

    title = 'Tracks for {0} angles and {1} cm spacing'.format(num_azim, spacing)
    plt.title(title)

    # Restore settings if called from ipython
    matplotlib.rcParams.update(curr_rc)

    # Save the figure to a file or return to user
    if get_figure:
        return fig
    else:
        filename = \
            'tracks-{1}-angles-{2}.png'.format(directory, num_azim, spacing)
        fig.savefig(directory+filename, bbox_inches='tight')
        plt.close(fig)


##
# @brief Plots the characteristic Track segments from an OpenMOC simulation.
# @details This method requires that tracks have been generated by a
#          TrackGenerator object. Each segment is colored by the ID of the
#          unique flat source region it is within. A user may invoke
#          this function from an OpenMOC Python file as follows:
#
# @code
#         openmoc.plotter.plot_segments(track_generator)
# @endcode
#
# @param track_generator the TrackGenerator which has generated Tracks
# @param get_figure whether or not to return the Matplotlib figure
def plot_segments(track_generator, get_figure=False):

    global subdirectory, matplotlib_rcparams
    directory = openmoc.get_output_directory() + subdirectory

    # Ensure that normal settings are used even if called from ipython
    curr_rc = dict(matplotlib.rcParams)
    matplotlib.rcParams.update(matplotlib_rcparams)

    # Make directory if it does not exist
    if not os.path.exists(directory):
        os.makedirs(directory)

    # Error checking
    if 'TrackGenerator' not in str(type(track_generator)):
        py_printf('ERROR', 'Unable to plot Track segments from %s ' +
                  'rather than a TrackGenerator', str(type(track_generator)))

    if not track_generator.containsTracks():
        py_printf('ERROR', 'Unable to plot Track segments since the ' +
                  'TrackGenerator has not yet generated Tracks.')

    py_printf('NORMAL', 'Plotting the track segments...')

    # Retrieve data from TrackGenerator
    vals_per_segment = openmoc.NUM_VALUES_PER_RETRIEVED_SEGMENT
    num_azim = track_generator.getNumAzim()
    spacing = track_generator.getTrackSpacing()
    num_segments = track_generator.getNumSegments()
    num_fsrs = track_generator.getGeometry().getNumFSRs()
    coords = \
        track_generator.retrieveSegmentCoords(num_segments*vals_per_segment)

    # Convert data to NumPy arrays
    coords = np.array(coords)
    x = np.zeros(num_segments*2)
    y = np.zeros(num_segments*2)
    z = np.zeros(num_segments*2)
    fsrs = np.zeros(num_segments)

    for i in range(num_segments):
        fsrs[i] = coords[i*vals_per_segment]
        x[i*2] = coords[i*vals_per_segment+1]
        y[i*2] = coords[i*vals_per_segment+2]
        z[i*2] = coords[i*vals_per_segment+3]
        x[i*2+1] = coords[i*vals_per_segment+4]
        y[i*2+1] = coords[i*vals_per_segment+5]
        z[i*2+1] = coords[i*vals_per_segment+6]

    # Create array of equally spaced randomized floats as a color map for plots
    # Seed the NumPy random number generator to ensure reproducible color maps
    numpy.random.seed(1)
    color_map = np.linspace(0., 1., num_fsrs, endpoint=False)
    numpy.random.shuffle(color_map)

    # Make figure of line segments for each track
    fig = plt.figure()
    fig.patch.set_facecolor('none')

    # Create a color map corresponding to FSR IDs
    for i in range(num_segments):
        cNorm  = colors.Normalize(vmin=0, vmax=max(color_map))
        scalarMap = cmx.ScalarMappable(norm=cNorm)
        color = scalarMap.to_rgba(color_map[fsrs[i] % num_fsrs])
        plt.plot([x[i*2], x[i*2+1]], [y[i*2], y[i*2+1]], c=color)

    plt.xlim([x.min(), x.max()])
    plt.ylim([y.min(), y.max()])

    suptitle = 'Segments ({0} angles, {1} cm spacing)'.format(num_azim, spacing)
    title = 'z = {0}'.format(z[0])
    plt.suptitle(suptitle)
    plt.title(title)

    # Restore settings if called from ipython
    matplotlib.rcParams.update(curr_rc)

    if get_figure:
        return fig
    else:
        filename = 'segments-{0}-angles-{1}-spacing'.format(num_azim, spacing)
        filename = '{0}-z-{1}.png'.format(filename, z[0])
        fig.savefig(directory+filename, bbox_inches='tight')
        plt.close(fig)


##
# @brief This method takes in a Geometry object and plots a color-coded 2D
#        surface plot representing the Materials in the Geometry.
# @details The Geometry object must be initialized with Materials, Cells,
#          Universes and lattices before being passed into this method. A user
#          may invoke this function from an OpenMOC Python file as follows:
#
# @code
#         openmoc.plotter.plot_materials(geometry)
# @endcode
#
# @param geometry a geometry object which has been initialized with Materials,
#        Cells, Universes and Lattices
# @param gridsize an optional number of grid cells for the plot
# @param xlim optional list/tuple of the minimim/maximum x-coordinates
# @param ylim optional list/tuple of the minimim/maximum y-coordinates
# @param zcoord optional the z coordinate (default is 0.0)
# @param get_figure whether to return the Matplotlib figure
# @param library the plotting library ('matplotlib' or 'pil')
def plot_materials(geometry, gridsize=250, xlim=None, ylim=None, zcoord=None,
                   get_figure=False, library='matplotlib'):

    py_printf('NORMAL', 'Plotting the materials...')

    # Create an array of random integer colors for each Material
    materials = geometry.getAllMaterials()
    num_materials = len(materials)
    colors = np.arange(num_materials)
    numpy.random.seed(1)
    numpy.random.shuffle(colors)
    for i, material_id in enumerate(materials):
        materials[material_id] = colors[i]

    # Initialize plotting parameters
    plot_params = PlotParams()
    plot_params.geometry = geometry
    plot_params.domain_type = 'material'
    plot_params.gridsize = gridsize
    plot_params.library = library
    plot_params.xlim = xlim
    plot_params.ylim = ylim
    plot_params.zcoord = zcoord
    plot_params.suptitle = 'Materials'
    plot_params.title = 'z = {0}'.format(plot_params.zcoord)
    plot_params.filename = 'materials-z-{0}'.format(plot_params.zcoord)
    plot_params.interpolation = 'nearest'
    plot_params.vmin = 0
    plot_params.vmax = num_materials

    # Plot a 2D color map of the Materials
    figures = plot_spatial_data(materials, plot_params, get_figure)

    # Return the figure to the user if requested
    if get_figure:
        return figures[0]


##
# @brief This method takes in a Geometry object and plots a color-coded 2D
#        surface plot representing the Cells in the Geometry.
# @details The geometry object must be initialized with Materials, Cells,
#          Universes and Lattices before being passed into this method. A user
#          may invoke this function from an OpenMOC Python file as follows:
#
# @code
#         openmoc.plotter.plot_cells(geometry)
# @endcode
#
# @param geometry a Geometry object which has been initialized with Materials,
#        Cells, Universes and Lattices
# @param gridsize an optional number of grid cells for the plot
# @param xlim optional list/tuple of the minimim/maximum x-coordinates
# @param ylim optional list/tuple of the minimim/maximum y-coordinates
# @param zcoord optional the z coordinate (default is 0.0)
# @param get_figure whether to return the Matplotlib figure
# @param library the plotting library ('matplotlib' or 'pil')
def plot_cells(geometry, gridsize=250, xlim=None, ylim=None,
               zcoord=None, get_figure=False, library='matplotlib'):

    py_printf('NORMAL', 'Plotting the cells...')

    # Create an array of random integer colors for each Cell
    cells = geometry.getAllMaterialCells()
    num_cells = len(cells)
    colors = np.arange(num_cells)
    numpy.random.seed(1)
    numpy.random.shuffle(colors)
    for i, cell_id in enumerate(cells):
        cells[cell_id] = colors[i]

    # Initialize plotting parameters
    plot_params = PlotParams()
    plot_params.geometry = geometry
    plot_params.domain_type = 'cell'
    plot_params.gridsize = gridsize
    plot_params.library = library
    plot_params.xlim = xlim
    plot_params.ylim = ylim
    plot_params.zcoord = zcoord
    plot_params.suptitle = 'Cells'
    plot_params.title = 'z = {0}'.format(plot_params.zcoord)
    plot_params.filename = 'cells-z-{0}'.format(plot_params.zcoord)
    plot_params.interpolation = 'nearest'
    plot_params.vmin = 0
    plot_params.vmax = num_cells

    # Plot a 2D color map of the Cells
    figures = plot_spatial_data(cells, plot_params, get_figure)

    # Return the figure to the user if requested
    if get_figure:
        return figures[0]


##
# @brief This method takes in a Geometry object and plots a color-coded 2D
#        surface plot representing the flat source regions in the Geometry.
#        The FSR centroids are plotted as black circles on top of the FSRs if
#        the centroids boolean is set to True.
# @details The Geometry object must be initialized with Materials, Cells,
#          Universes and Lattices before being passed into this method. A user
#          may invoke this function from an OpenMOC Python file as follows:
#
# @code
#         openmoc.plotter.plot_flat_source_regions(geometry)
# @endcode
#
# @param geometry a geometry object which has been initialized with Materials,
#        Cells, Universes and Lattices
# @param gridsize an optional number of grid cells for the plot
# @param xlim optional list/tuple of the minimim/maximum x-coordinates
# @param ylim optional list/tuple of the minimim/maximum y-coordinates
# @param centroids optional boolean to plot the FSR centroids
# @param marker_type optional string to set the centroids marker type
# @param marker_size optional int/float to set the centroids marker size
# @param get_figure whether to return the Matplotlib figure
# @param library the plotting library ('matplotlib' or 'pil')
def plot_flat_source_regions(geometry, gridsize=250, xlim=None, ylim=None,
                             centroids=False, marker_type='o', marker_size=2,
                             get_figure=False, library='matplotlib'):

    global subdirectory, matplotlib_rcparams
    directory = openmoc.get_output_directory() + subdirectory

    if not isinstance(centroids, bool):
        py_printf('ERROR', 'Unable to plot the flat source regions since ' +
                  'centroids is not a boolean')

    if not isinstance(marker_type, str):
        py_printf('ERROR', 'Unable to plot the flat source regions since ' +
                  'marker_type is a string')

    if marker_type not in matplotlib.markers.MarkerStyle().markers.keys():
        py_printf('ERROR', 'Unable to plot the flat source regions since ' +
                  'marker_type is not a valid marker (%d)', marker_type)

    if not is_float(marker_size) and not is_integer(marker_size):
        py_printf('ERROR', 'Unable to plot the flat source regions since ' +
                  'marker_size is not an int or float', marker_size)

    if marker_size <= 0:
        py_printf('ERROR', 'Unable to plot the flat source regions ' +
                  'with a negative marker_size (%d)', marker_size)

    if geometry.getNumFSRs() == 0:
        py_printf('ERROR', 'Unable to plot the flat source regions ' +
                  'since no tracks have been generated.')

    py_printf('NORMAL', 'Plotting the flat source regions...')

    num_fsrs = geometry.getNumFSRs()
    fsrs_to_fsrs = np.arange(num_fsrs, dtype=np.int64)
    fsrs_to_fsrs = _colorize(fsrs_to_fsrs, num_fsrs)

    # Initialize plotting parameters
    zcoord = geometry.getFSRPoint(0).getZ()
    plot_params = PlotParams()
    plot_params.geometry = geometry
    plot_params.zcoord = zcoord
    plot_params.gridsize = gridsize
    plot_params.library = library
    plot_params.xlim = xlim
    plot_params.ylim = ylim
    plot_params.suptitle = 'Flat Source Regions'
    plot_params.title = 'z = {0}'.format(zcoord)
    plot_params.filename = 'flat-source-regions-z-{0}'.format(zcoord)
    plot_params.interpolation = 'nearest'
    plot_params.vmin = 0
    plot_params.vmax = num_fsrs

    # Plot a 2D color map of the flat source regions
    figures = plot_spatial_data(fsrs_to_fsrs, plot_params, get_figure=True)
    fig = figures[0]

    # Plot centroids on top of 2D flat source region color map
    if centroids:

        # Populate a NumPy array with the FSR centroid coordinates
        centroids = np.zeros((num_fsrs, 2), dtype=np.float)
        for fsr_id in range(num_fsrs):
            point = geometry.getFSRCentroid(fsr_id)
            centroids[fsr_id,:] = [point.getX(), point.getY()]

        # Plot centroids on figure using matplotlib
        if library == 'pil':

            # Retrieve the plot bounds
            coords = _get_pixel_coords(plot_params)
            r = marker_size

            # Open a PIL ImageDraw portal on the Image object
            from PIL import ImageDraw
            draw = ImageDraw.Draw(fig)

            for fsr_id in range(num_fsrs):
                # Retrieve the pixel coordinates for this centroid
                x, y = centroids[fsr_id,:]

                # Only plot centroid if it is within the plot bounds
                if x < coords['bounds'][0] or x > coords['bounds'][1]:
                    continue
                elif y < coords['bounds'][2] or y > coords['bounds'][3]:
                    continue

                # Transform the centroid into pixel coordinates
                x = int((x-coords['x'][1]) / (coords['x'][1]-coords['x'][0]))
                y = int((y-coords['y'][1]) / (coords['y'][1]-coords['y'][0]))

                # Draw circle for this centroid on the image
                draw.ellipse((x-r, y-r, x+r, y+r), fill=(0, 0, 0))

        # Plot centroids on figure using PIL
        else:
            plt.scatter(centroids[:,0], centroids[:,1], color='k',
                        marker=marker_type, s=marker_size)

    # Return the figure to the user if requested
    if get_figure:
        return figures[0]
    # Set the plot title and save the figure
    else:
        plot_filename = directory + plot_params.filename + plot_params.extension

        if library == 'pil':
            fig.save(plot_filename)
        else:
            fig.savefig(plot_filename, bbox_inches='tight')
            plt.close(fig)


##
# @brief This method takes in a Geometry and Cmfd object and plots a
#        color-coded 2D surface plot representing the CMFD cells in a geometry.
# @details The Geometry object must be initialized with Materials, Cells,
#          Universes and Lattices before being passed into this method.
#          Plotting the CMFD cells requires that segments must have been
#          created for the geometry and FSR IDs assigned to regions. A user
#          may invoke this function from an OpenMOC Python file as follows:
#
# @code
#         openmoc.plotter.plot_cmfd_cells(geometry, cmfd)
# @endcode
#
# @param geometry a geometry object which has been initialized with Materials,
#        Cells, Universes and Lattices. Segments must have been created or
#        extracted from a file.
# @param cmfd a Cmfd object which has been used with the geometry in
#        generating segments. The Cmfd object must have the _overlay_mesh
#        flag set to true; otherwise, the map linking FSR IDs to CMFD cells
#        would not have been created.
# @param gridsize an optional number of grid cells for the plot
# @param xlim optional list/tuple of the minimim/maximum x-coordinates
# @param ylim optional list/tuple of the minimim/maximum y-coordinates
# @param get_figure whether to return the Matplotlib figure
# @param library the plotting library ('matplotlib' or 'pil')
def plot_cmfd_cells(geometry, cmfd, gridsize=250, xlim=None, ylim=None,
                    get_figure=False, library='matplotlib'):

    py_printf('NORMAL', 'Plotting the CMFD cells...')

    if 'Cmfd' not in str(type(cmfd)):
        py_printf('ERROR', 'Unable to plot the CMFD cells since %s ' +
                  'input is not a CMFD class object', str(cmfd))

    # Create a NumPy array to map FSRs to CMFD cells
    num_fsrs = geometry.getNumFSRs()
    fsrs_to_cmfd_cells = np.zeros(num_fsrs, dtype=np.int64)
    for fsr_id in range(num_fsrs):
        fsrs_to_cmfd_cells[fsr_id] = cmfd.convertFSRIdToCmfdCell(fsr_id)

    # Assign random color scheme to CMFD cells
    num_cmfd_cells = cmfd.getNumCells()
    fsrs_to_cmfd_cells = _colorize(fsrs_to_cmfd_cells, num_cmfd_cells)

    # Initialize plotting parameters
    zcoord = geometry.getFSRPoint(0).getZ()
    plot_params = PlotParams()
    plot_params.geometry = geometry
    plot_params.zcoord = zcoord
    plot_params.gridsize = gridsize
    plot_params.library = library
    plot_params.xlim = xlim
    plot_params.ylim = ylim
    plot_params.suptitle = 'CMFD Cells'
    plot_params.title = 'z = {0}'.format(zcoord)
    plot_params.filename = 'cmfd-cells-{0}'.format(zcoord)
    plot_params.interpolation = 'nearest'
    plot_params.vmin = 0
    plot_params.vmax = num_cmfd_cells

    # Plot the CMFD cells
    figures = plot_spatial_data(fsrs_to_cmfd_cells, plot_params, get_figure)

    # Return the figure to the user if requested
    if get_figure:
        return figures[0]


##
# @brief This method takes in a Solver object and plots a color-coded 2D
#        surface plot representing the flat source region scalar fluxes.
# @details The Solver must have converged the flat source sources prior to
#          calling this routine. A user may invoke this function from an
#          OpenMOC Python file as follows:
#
# @code
#         openmoc.plotter.plot_spatial_fluxes(solver, energy_groups=[1,7])
# @endcode
#
# @param solver a Solver object that has converged the source for the Geometry
# @param energy_groups a Python list of integer energy groups to plot
# @param norm normalize the fluxes to the maximum flux
# @param gridsize an optional number of grid cells for the plot
# @param xlim optional list/tuple of the minimim/maximum x-coordinates
# @param ylim optional list/tuple of the minimim/maximum y-coordinates
# @param get_figure whether to a return a list of Matplotlib figures
# @param library the plotting library ('matplotlib' or 'pil')
def plot_spatial_fluxes(solver, energy_groups=[1], norm=False, gridsize=250,
                        xlim=None, ylim=None, get_figure=False,
                        library='matplotlib'):

    if 'Solver' not in str(type(solver)):
        py_printf('ERROR', 'Unable to plot the FSR flux since the ' +
                  'input did not contain a solver class object')

    if not isinstance(energy_groups, (list, tuple, np.ndarray)):
        py_printf('ERROR', 'Unable to plot the FSR flux since the ' +
                  'energy_groups is not a Python tuple/list or NumPy array')

    py_printf('NORMAL', 'Plotting the FSR scalar fluxes...')

    # Initialize plotting parameters
    geometry = solver.getGeometry()
    zcoord = geometry.getFSRPoint(0).getZ()
    plot_params = PlotParams()
    plot_params.geometry = geometry
    plot_params.zcoord = zcoord
    plot_params.gridsize = gridsize
    plot_params.library = library
    plot_params.xlim = xlim
    plot_params.ylim = ylim
    plot_params.colorbar = True
    plot_params.cmap = plt.get_cmap('jet')
    plot_params.norm = norm

    # Get array of FSR energy-dependent fluxes
    fluxes = get_scalar_fluxes(solver)

    # Initialize an empty list of Matplotlib figures if requestd by the user
    figures = []

    # Loop over all energy group and create a plot
    for index, group in enumerate(energy_groups):
        plot_params.suptitle = 'FSR Scalar Flux (Group {0})'.format(group)
        plot_params.title = 'z = {0}'.format(zcoord)
        plot_params.filename = 'fsr-flux-group-{0}-z-{1}'.format(group, zcoord)
        fig = plot_spatial_data(fluxes[:,index], plot_params, get_figure)

        if get_figure:
            figures.append(fig[0])

    # Return figures if requested by the user
    if get_figure:
        return figures


##
# @brief This method takes in a CPULSSolver object and plots a color-coded 2D
#        surface plot representing the linear source region scalar fluxes.
# @details The Solver must have converged the linear source sources prior to
#          calling this routine. A user may invoke this function from an
#          OpenMOC Python file as follows:
#
# @code
#         openmoc.plotter.plot_spatial_fluxes_ls(solver, energy_groups=[1,7])
# @endcode
#
# @param solver a CPULSSolver object that has converged the source for the
#               Geometry
# @param energy_groups a Python list of integer energy groups to plot
# @param norm normalize the fluxes to the maximum flux
# @param gridsize an optional number of grid cells for the plot
# @param xlim optional list/tuple of the minimim/maximum x-coordinates
# @param ylim optional list/tuple of the minimim/maximum y-coordinates
# @param get_figure whether to a return a list of Matplotlib figures
# @param library the plotting library ('matplotlib' or 'pil')
def plot_spatial_fluxes_ls(solver, energy_groups=[1], norm=False, gridsize=250,
                           xlim=None, ylim=None, get_figure=False,
                           library='matplotlib'):

    if 'CPULSSolver' not in str(type(solver)):
        py_printf('ERROR', 'Unable to plot the LSR flux since the ' +
                  'input did not contain a CPULSSolver class object')

    if not isinstance(energy_groups, (list, tuple, np.ndarray)):
        py_printf('ERROR', 'Unable to plot the LSR flux since the ' +
                  'energy_groups is not a Python tuple/list or NumPy array')

    global subdirectory, matplotlib_rcparams
    directory = openmoc.get_output_directory() + subdirectory

    # Make directory if it does not exist
    if not os.path.exists(directory):
        os.makedirs(directory)

    py_printf('NORMAL', 'Plotting the LSR scalar fluxes...')

    # Initialize plotting parameters
    geometry = solver.getGeometry()
    zcoord = geometry.getFSRPoint(0).getZ()
    plot_params = PlotParams()
    plot_params.geometry = geometry
    plot_params.zcoord = zcoord
    plot_params.gridsize = gridsize
    plot_params.library = library
    plot_params.xlim = xlim
    plot_params.ylim = ylim
    plot_params.colorbar = True
    plot_params.cmap = plt.get_cmap('jet')
    plot_params.norm = norm

    data = np.zeros((len(energy_groups), plot_params.gridsize, plot_params.gridsize), dtype=np.float)

    # Retrieve the pixel coordinates
    coords = _get_pixel_coords(plot_params)

    for i in range(plot_params.gridsize):
        for j in range(plot_params.gridsize):

            # Find the domain IDs for each grid point
            x = coords['x'][i]
            y = coords['y'][j]

            point = openmoc.LocalCoords(x, y, plot_params.zcoord)
            for g,group in enumerate(energy_groups):
                data[g][j][i] = solver.getFluxByCoords(point, group-1)

    for g,group in enumerate(energy_groups):
        fig = plt.figure()
        fig.patch.set_facecolor('none')
        plt.imshow(np.flipud(data[g]), extent=coords['bounds'],
                   interpolation=plot_params.interpolation,
                   vmin=plot_params.vmin, vmax=plot_params.vmax,
                   cmap=plot_params.cmap)
        plt.colorbar()
        filename = 'lsr-flux-group-{0}.png'.format(group)
        plt.savefig(directory+filename, bbox_inches='tight')


##
# @brief This method takes in a Solver object and plots the scalar
#        flux vs. energy for one or more flat source regions.
# @details The Solver must have converged the flat source sources prior to
#          calling this routine. The routine will generate a step plot of the
#          flat flux across each energy group.
#
#          An optional parameter for the energy group bounds may be input.
#          The group bounds should be input in increasing order of energy.
#          If group bounds are not specified, the routine will use equal
#          width steps for each energy group.
#
#          A user may invoke this function from an OpenMOC Python file
#          as follows:
#
# @code
#         openmoc.plotter.plot_energy_fluxes(solver, fsrs=[1,5,20],
#                                            group_bounds=[0., 0.625, 2e7])
# @endcode
#
# @param solver a Solver object that has converged the source for the Geometry
# @param fsrs the flat source region IDs of interest
# @param group_bounds an optional Python list of the energy group bounds (eV)
# @param norm normalize the fluxes to the total energy-integrated flux
# @param loglog boolean indicating whether to plot use a log-log scale
# @param get_figure return a list of the Matplotlib figures
def plot_energy_fluxes(solver, fsrs, group_bounds=None, norm=True,
                       loglog=True, get_figure=False):

    global subdirectory, matplotlib_rcparams
    directory = openmoc.get_output_directory() + subdirectory

    # Ensure that normal settings are used even if called from ipython
    curr_rc = dict(matplotlib.rcParams)
    matplotlib.rcParams.update(matplotlib_rcparams)

    # Make directory if it does not exist
    if not os.path.exists(directory):
        os.makedirs(directory)

    if 'Solver' not in str(type(solver)):
      py_printf('ERROR', 'Unable to plot the flux vs. energy ' +
                'since input did not contain a Solver class object')

    geometry = solver.getGeometry()
    num_fsrs = geometry.getNumFSRs()
    num_groups = geometry.getNumEnergyGroups()

    if isinstance(fsrs, (tuple, list, np.ndarray)):
        for fsr in fsrs:
            if not is_integer(fsr):
                py_printf('ERROR', 'Unable to plot the flux vs. energy ' +
                          'non-integer FSR %s', str(fsr))

            elif fsr < 0:
                py_printf('ERROR', 'Unable to plot the flux vs. energy ' +
                          'for negative FSR %d', fsr)

            elif fsr >= num_fsrs:
                py_printf('ERROR', 'Unable to plot the flux vs. energy ' +
                          'for FSR %d in problem with %d FSRs', fsr, num_fsrs)

    else:
        py_printf('ERROR', 'Unable to plot the flux vs. energy since ' +
                  'the fsrs is not a Python tuple, list or NumPy array')

    if isinstance(group_bounds, (tuple, list, np.ndarray)):

        if not all(low < up for low, up in zip(group_bounds, group_bounds[1:])):
            py_printf('ERROR', 'Unable to plot the flux vs. energy since ' +
                      'the group bounds are not monotonically increasing')

        elif len(group_bounds) != geometry.getNumEnergyGroups()+1:
            py_printf('ERROR', 'Unable to plot the flux vs. energy with ' +
                      '%d group bounds', len(group_bounds))

        for bound in group_bounds:
            if not is_integer(bound) and not is_float(bound):
                py_printf('ERROR', 'Unable to plot the flux vs. energy ' +
                          'with group bound %s', str(fsr))

            elif bound < 0:
                py_printf('ERROR', 'Unable to plot the flux vs. energy ' +
                          'with a negative group bound %f', bound)

    elif group_bounds is None:
        group_bounds = np.arange(num_groups+1, dtype=np.int)
        loglog = False

    else:
        py_printf('ERROR', 'Unable to plot the flux vs. energy since ' +
                  'the group bounds is not a Python tuple, list or NumPy array')

    py_printf('NORMAL', 'Plotting the scalar fluxes vs. energy...')

    # Compute difference in energy bounds for each group
    group_deltas = np.ediff1d(group_bounds)
    group_bounds = np.flipud(group_bounds)
    group_deltas = np.flipud(group_deltas)

    # Initialize an empty list of Matplotlib figures if requestd by the user
    figures = []

    # Iterate over all flat source regions
    for fsr in fsrs:

        # Allocate memory for an array of this FSR's fluxes
        fluxes = np.zeros(num_groups, dtype=np.float)

        # Extract the flux in each energy group
        for group in range(num_groups):
            fluxes[group] = solver.getFlux(fsr, group+1)

        # Normalize fluxes to the total integrated flux
        if norm:
            fluxes /= np.sum(group_deltas * fluxes)

        # Initialize a separate plot for this FSR's fluxes
        fig = plt.figure()
        fig.patch.set_facecolor('none')

        # Draw horizontal/vertical lines on the plot for each energy group
        for group in range(num_groups):

            # Horizontal line
            if loglog:
                plt.loglog(group_bounds[group:group+2], [fluxes[group]]*2,
                           linewidth=3, c='b', label='openmoc', linestyle='-')
            else:
                plt.plot(group_bounds[group:group+2], [fluxes[group]]*2,
                         linewidth=3, c='b', label='openmoc', linestyle='-')

            # Vertical lines
            if group < num_groups - 1:
                if loglog:
                    plt.loglog([group_bounds[group+1]]*2, fluxes[group:group+2],
                               c='b', linestyle='--')
                else:
                    plt.plot([group_bounds[group+1]]*2, fluxes[group:group+2],
                             c='b', linestyle='--')

        plt.xlabel('Energy')
        plt.ylabel('Flux')
        plt.xlim((min(group_bounds), max(group_bounds)))
        plt.grid()
        plt.title('FSR {0} Flux ({1} groups)'.format(fsr, num_groups))

        # Save the figure to a file or return to user if requested
        if get_figure:
            figures.append(fig)
        else:
            filename = 'flux-fsr-{0}.png'.format(fsr)
            plt.savefig(directory+filename, bbox_inches='tight')
            plt.close(fig)

    # Restore settings if called from ipython
    matplotlib.rcParams.update(curr_rc)

    # Return the figures if requested by user
    if get_figure:
        return figures


def plot_exp_evaluator(precision=1.e-5, max_tau=10.0):

    exp_eval = openmoc.ExpEvaluator()
    polar_quad = openmoc.TYPolarQuad()
    polar_quad.setNumPolarAngles(3)
    polar_quad.initialize()
    exp_eval.setPolarQuadrature(polar_quad)
    exp_eval.setMaxOpticalLength(max_tau)
    exp_eval.setExpPrecision(precision)
    exp_eval.initialize()
    table_size = exp_eval.getTableSize()

    py_printf('NORMAL', 'table size %d', table_size)

    # create query arrays
    test_size = int(10*table_size)
    exp_interp = np.zeros((4,test_size))
    exp_intrin = np.zeros((4,test_size))
    exp_error = np.zeros((4,test_size))
    test_tau = np.linspace(0, max_tau, test_size)

    # query interpolated values
    for i,t in enumerate(test_tau):
        exp_interp[0][i] = exp_eval.computeExponential(t,0)
        exp_interp[1][i] = exp_eval.computeExponentialF2(t,0)
        exp_interp[2][i] = exp_eval.computeExponentialG1(t,0)
        exp_interp[3][i] = exp_eval.computeExponentialG2(t,0)

    exp_eval.useIntrinsic()

    # query intrinsic values
    for i,t in enumerate(test_tau):
        exp_intrin[0][i] = exp_eval.computeExponential(t,0)
        exp_intrin[1][i] = exp_eval.computeExponentialF2(t,0)
        exp_intrin[2][i] = exp_eval.computeExponentialG1(t,0)
        exp_intrin[3][i] = exp_eval.computeExponentialG2(t,0)

    exp_error = (exp_interp - exp_intrin)

    fig = plt.figure()
    plt.semilogy(test_tau, exp_error[0], label='F1')
    plt.semilogy(test_tau, exp_error[1], label='F2')
    plt.semilogy(test_tau, exp_error[2], label='G1')
    plt.semilogy(test_tau, exp_error[3], label='G2')
    plt.ylabel('Error')
    plt.xlabel('Tau')
    plt.legend()
    plt.savefig('plots/exp_error.png')

    exp_error = exp_error / exp_intrin * 100.0

    fig = plt.figure()
    plt.semilogy(test_tau, exp_error[0], label='F1')
    plt.semilogy(test_tau, exp_error[1], label='F2')
    plt.semilogy(test_tau, exp_error[2], label='G1')
    plt.semilogy(test_tau, exp_error[3], label='G2')
    plt.ylabel('Relative Error (%)')
    plt.xlabel('Tau')
    plt.legend()
    plt.savefig('plots/exp_rel_error.png')

    fig = plt.figure()
    plt.plot(test_tau, exp_intrin[0], label='F1')
    plt.plot(test_tau, exp_intrin[1], label='F2')
    plt.plot(test_tau, exp_intrin[2], label='G1')
    plt.plot(test_tau, exp_intrin[3], label='G2')
    plt.ylabel('Exponential Intrinsic')
    plt.xlabel('Tau')
    plt.legend(loc=2)
    plt.savefig('plots/exp_intrin.png')

    fig = plt.figure()
    plt.plot(test_tau, exp_interp[0], label='F1')
    plt.plot(test_tau, exp_interp[1], label='F2')
    plt.plot(test_tau, exp_interp[2], label='G1')
    plt.plot(test_tau, exp_interp[3], label='G2')
    plt.ylabel('Exponential Interpolation')
    plt.xlabel('Tau')
    plt.legend(loc=2)
    plt.savefig('plots/exp_interp.png')


##
# @brief This method plots a color-coded 2D surface plot representing the
#        FSR fission rates in the Geometry.
# @details The Solver must have converged the flat source sources prior to
#          calling this routine. A user may invoke this function from an
#          OpenMOC Python file as follows:
#
# @code
#         openmoc.plotter.plot_fission_rates(solver)
# @endcode
#
# @param solver a Solver object that has converged the source for the Geometry
# @param norm normalize the fission rates to the maximum fission rate
# @param transparent_zeros make regions without fission transparent
# @param gridsize an optional number of grid cells for the plot
# @param xlim optional list/tuple of the minimim/maximum x-coordinates
# @param ylim optional list/tuple of the minimim/maximum y-coordinates
# @param get_figure whether to return the Matplotlib figure
# @param library the plotting library ('matplotlib' or 'pil')
def plot_fission_rates(solver, norm=False, transparent_zeros=True, gridsize=250,
                       xlim=None, ylim=None, get_figure=False,
                       library='matplotlib'):

    py_printf('NORMAL', 'Plotting the flat source region fission rates...')

    if 'Solver' not in str(type(solver)):
        py_printf('ERROR', 'Unable to plot the fission rates ' +
                  'since input did not contain a solver class object')

    # Compute the volume-weighted fission rates for each FSR
    geometry = solver.getGeometry()
    fission_rates = solver.computeFSRFissionRates(geometry.getNumFSRs())

    # Initialize plotting parameters
    zcoord = geometry.getFSRPoint(0).getZ()
    plot_params = PlotParams()
    plot_params.geometry = geometry
    plot_params.zcoord = zcoord
    plot_params.gridsize = gridsize
    plot_params.library = library
    plot_params.xlim = xlim
    plot_params.ylim = ylim
    plot_params.suptitle = 'Flat Source Region Fission Rates'
    plot_params.title = 'z = {0}'.format(zcoord)
    plot_params.filename = 'fission-rates-z-{0}.png'.format(zcoord)
    plot_params.transparent_zeros = True
    plot_params.colorbar = True
    plot_params.cmap = plt.get_cmap('jet')
    plot_params.norm = norm

    # Plot the fission rates
    figures = plot_spatial_data(fission_rates, plot_params, get_figure)

    # Return the figure if requested by user
    if get_figure:
        return figures[0]


##
# @brief This method plots a color-coded 2D surface plot representing the
#        FSR scalar fluxes for various eigenmodes from an IRAMSolver.
# @details The IRAMSolver must have computed the eigenmodes prior to
#          calling this routine. A user may invoke this function from
#          an OpenMOC Python file as follows:
#
# @code
#         openmoc.plotter.plot_eigenmode_fluxes(iramsolver, energy_groups=[1,7])
# @endcode
#
# @param iramsolver an IRAMSolver object that has computed the eigenmodes
# @param eigenmodes a Python list of integer eigenmodes to plot
# @param energy_groups a Python list of integer energy groups to plot
# @param norm normalize the fluxes to the maximum flux
# @param gridsize an optional number of grid cells for the plot
# @param xlim optional list/tuple of the minimim/maximum x-coordinates
# @param ylim optional list/tuple of the minimim/maximum y-coordinates
# @param get_figure whether to return a list of Matplotlib figures
# @param library the plotting library ('matplotlib' or 'pil')
def plot_eigenmode_fluxes(iramsolver, eigenmodes=[], energy_groups=[1],
                          norm=False, gridsize=250, xlim=None, ylim=None,
                          get_figure=False, library='matplotlib'):

    global subdirectory
    directory = openmoc.get_output_directory() + subdirectory

    # Make directory if it does not exist
    if not os.path.exists(directory):
        os.makedirs(directory)

    if 'IRAMSolver' not in str(type(iramsolver)):
      py_printf('ERROR', 'Unable to plot the eigenmode fluxes ' +
                'since input did not contain an IRAMSolver class object')

    # Get the total number of eigenmodes
    num_modes = iramsolver._num_modes

    if isinstance(eigenmodes, (list, tuple, np.ndarray)):

        # If eigenmodes parameters is empty list, plot all eigenmodes
        if len(eigenmodes) == 0:
          eigenmodes = np.arange(1, num_modes+1)

        for mode in eigenmodes:
            if not is_integer(mode):
                py_printf('ERROR', 'Unable to plot the eigenmode flux ' +
                          'for eigenmode %s', str(mode))

            elif mode <= 0:
                py_printf('ERROR', 'Unable to plot the eigenmode flux ' +
                          'for negative eigenmode %d', mode)

            elif mode > num_modes:
                py_printf('ERROR', 'Unable to plot the eigenmode flux for ' +
                          'eigenmode %d out of %d modes', mode, num_modes)

    else:
        py_printf('ERROR', 'Unable to plot the eigenmode flux since the ' +
                  'eigenmodes is not a Python tuple/list or NumPy array')

    py_printf('NORMAL', 'Plotting the eigenmode fluxes...')

    # Extract the MOC Solver from the IRAMSolver
    moc_solver = iramsolver._moc_solver

    # Initialize a list of figures to return to user if requested
    figures = []

    # Loop over each eigenmode
    for mode in eigenmodes:

        # Extract the eigenvector for this eigenmode from the IRAMSolver
        eigenvec = iramsolver._eigenvectors[:,mode-1]

        # Convert it into a form that SWIG will be happy with
        eigenvec = np.squeeze(np.ascontiguousarray(eigenvec))
        eigenvec = np.real(eigenvec).astype(iramsolver._precision)

        # Ensure the primary eigenvector is positive
        if mode == 1:
            eigenvec = np.abs(eigenvec)

        # Insert eigenvector into MOC Solver object
        moc_solver.setFluxes(eigenvec)

        # Set subdirectory folder for this eigenmode
        num_digits = len(str(max(eigenmodes)))
        subdirectory = \
            '/plots/eig-{0}-flux/'.format(str(mode).zfill(num_digits))

        # Plot this eigenmode's spatial fluxes
        fig = plot_spatial_fluxes(moc_solver, energy_groups, norm, gridsize,
                                  xlim, ylim, get_figure, library)

        if get_figure:
            figures.append(fig[0])

    # Reset global subdirectory
    subdirectory = '/plots/'

    # Return Matplotlib figures if requested by user
    if get_figure:
        return figures


##
# @brief This method plots a color-coded 2D surface plot representing the
#        arbitrary data mapped to each domain in the geometry
# @details The second PlotParams parameter to this routine must include the
#          domain type encoded in the domains_to_data parameter. In the case
#          of 'material' and 'cell' domain types, the domains-to-data map must
#          be a Python dictionary with keys representing each Material/Cell ID
#          and values indicating the data to plot. In the case of the 'fsr'
#          domain type, the domains-to-data map may be a dictionary, NumPy array
#          or a Pandas DataFrame with indices representing FSR IDs and values
#          representing the data to plot.
#
#          A user may invoke this function from an Python file as follows:
#
# @code
#         fsrs_to_data = numpy.random.rand(geometry.getNumFSRS())
#         plot_params = PlotParams()
#         plot_params.domain_type = 'fsr'
#         openmoc.plotter.plot_spatial_data(fsrs_to_data, plot_params)
# @endcode
#
# @param domains_to_data a mapping between spatial domain IDs and numerical data
# @param plot_params a PlotParams object initialized with a Geometry
# @param get_figure whether to return a list of Matplotlib figures
# @return a list of Matplotlib figures, if requested
def plot_spatial_data(domains_to_data, plot_params, get_figure=False):

    global subdirectory, matplotlib_rcparams
    directory = openmoc.get_output_directory() + subdirectory

    # Make directory if it does not exist
    if not os.path.exists(directory):
        os.makedirs(directory)

    if not isinstance(plot_params, PlotParams):
        py_printf('ERROR', 'Unable to plot spatial data with %s which is'
                           'not a PlotParams object', str(plot_params))

    # Determine the number of domains
    if plot_params.domain_type == 'material':
        num_domains = len(plot_params.geometry.getAllMaterials())
    elif plot_params.domain_type == 'cell':
        num_domains = len(plot_params.geometry.getAllMaterialCells())
    else:
        num_domains = plot_params.geometry.getNumFSRs()

    if isinstance(domains_to_data, (np.ndarray, dict)):
        pandas_df = False
        if len(domains_to_data) != num_domains:
            py_printf('ERROR', 'The domains_to_data array is length %d but ' +
                      'there are %d domains', len(domains_to_data), num_domains)
    elif 'DataFrame' in str(type(domains_to_data)):
        pandas_df = True
        if len(domains_to_data) != plot_params.geometry.getNumFSRs():
            py_printf('ERROR', 'The domains_to_data DataFrame is length %d ' +
                      'but there are %d domains in the Geometry',
                      len(domains_to_data), num_domains)
    else:
        py_printf('ERROR', 'Unable to plot spatial data since ' +
                  'domains_to_data is not a dict, array or DataFrame')

    # Initialize a numpy array for the spatial data
    domains = np.zeros((plot_params.gridsize, plot_params.gridsize), dtype=np.int)

    # Retrieve the pixel coordinates
    coords = _get_pixel_coords(plot_params)

    for i in range(plot_params.gridsize):
        for j in range(plot_params.gridsize):

            # Find the domain IDs for each grid point
            x = coords['x'][i]
            y = coords['y'][j]

            point = openmoc.LocalCoords(x, y, plot_params.zcoord)
            point.setUniverse(plot_params.geometry.getRootUniverse())
            cell = plot_params.geometry.findCellContainingCoords(point)

            if plot_params.domain_type == 'fsr':
                domain_id = plot_params.geometry.getFSRId(point)
            elif plot_params.domain_type == 'material':
                domain_id = cell.getFillMaterial().getId()
            else:
                domain_id = cell.getId()

            # If we did not find a domain, use a -1 "bad" number color
            if np.isnan(domain_id):
                domains[j][i] = -1
            else:
                domains[j][i] = domain_id

    # Make domains-to-data array 2D to mirror a Pandas DataFrame
    if isinstance(domains_to_data, np.ndarray):
        domains_to_data.shape += (1,)

    # Determine the number of plots to generate
    if pandas_df or isinstance(domains_to_data, np.ndarray):
        num_plots = domains_to_data.shape[1]
    else:
        num_plots = int(len(domains_to_data) / num_domains)

    # Initialize a list of Matplotlib figures to return to user if requested
    figures = []

    # Loop over all columns in NumPy array or Pandas DataFrame input
    for i in range(num_plots):

        # Use domain IDs to appropriately index into FSR data
        # If domains-to-data was input as a Pandas DataFrame
        if pandas_df:
            surface = domains_to_data.ix[:,i].values
            surface = surface.take(domains.flatten())
        # If domains-to-data was input as a NumPy array
        elif isinstance(domains_to_data, np.ndarray):
            surface = domains_to_data.take(domains.flatten())
        # If domains-to-data was input as a Python dictionary
        else:
            surface = np.zeros(domains.shape, dtype=np.int)
            for domain_id in domains_to_data:
                indices = np.where(domains == domain_id)
                surface[indices] = domains_to_data[domain_id]

        # Reshape data to 2D array for Matplotlib image plot
        surface.shape = (plot_params.gridsize, plot_params.gridsize)

        # Normalize data to maximum if requested
        if plot_params.norm:
            surface /= np.max(surface)

        # Set zero data entries to NaN so Matplotlib will make them transparent
        if plot_params.transparent_zeros:
            indices = np.where(surface == 0.0)
            surface[indices] = np.nan

        # Color "bad" numbers (ie, NaN, INF) with transparent pixels
        if plot_params.cmap:
            plot_params.cmap.set_bad(alpha=0.0)

        # Create plot filename
        plot_filename = directory + plot_params.filename

        # If input was Pandas DataFrame, append column name to filename
        if pandas_df:
            plot_filename += '-{0}'.format(domains_to_data.columns[i])

        # Append file extension (e.g., '.png', '.ppm') to filename
        plot_filename += plot_params.extension

        # Use Python Imaging Library (PIL) to plot 2D color map of domain data
        if plot_params.library == 'pil':
            img = _get_pil_image(np.flipud(surface), plot_params)

            if get_figure:
                figures.append(img)
            else:
                img.save(plot_filename)

        # Use Matplotlib to plot 2D color map of domain data
        else:

            # Ensure that normal settings are used even if called from ipython
            curr_rc = dict(matplotlib.rcParams)
            matplotlib.rcParams.update(matplotlib_rcparams)

            fig = plt.figure()
            fig.patch.set_facecolor('none')
            plt.imshow(np.flipud(surface), extent=coords['bounds'],
                       interpolation=plot_params.interpolation,
                       vmin=plot_params.vmin, vmax=plot_params.vmax,
                       cmap=plot_params.cmap)

            if plot_params.colorbar:
                plt.colorbar()
            if plot_params.title:
                plt.title(plot_params.title)

            if plot_params.suptitle:
                # If input was Pandas DataFrame, append column name to suptitle
                if pandas_df:
                    suptitle = plot_params.suptitle
                    suptitle += ' ({0})'.format(domains_to_data.columns[i])
                else:
                    suptitle = plot_params.suptitle

                plt.suptitle(suptitle)

            # If the user requested the Matplotlib figure handles for further
            # specialization, append the handle to this figure to a list
            if get_figure:
                figures.append(fig)

            # Otherwise, save this Matplotlib figure
            else:
                fig.savefig(plot_filename, bbox_inches='tight')
                plt.close()

            # Restore settings if called from ipython
            matplotlib.rcParams.update(curr_rc)

    # Return Matplotlib figures if requested by user
    if get_figure:
        return figures


##
# @brief Plots the quadrature set used for an OpenMOC simulation.
# @details This method requires that Tracks have been generated by a
#          TrackGenerator object owned by the solver. A user may invoke this
#          function from an OpenMOC Python file as follows:
#
# @code
#         openmoc.plotter.plot_quadrature(solver)
# @endcode
#
# @param solver the Solver which has a TrackGenerator containing tracks and
#               PolarQuad object
# @param get_figure whether to return the Matplotlib figure
def plot_quadrature(solver, get_figure=False):

    global subdirectory, matplotlib_rcparams
    directory = openmoc.get_output_directory() + subdirectory

    # Ensure that normal settings are used even if called from ipython
    curr_rc = dict(matplotlib.rcParams)
    matplotlib.rcParams.update(matplotlib_rcparams)

    # Make directory if it does not exist
    if not os.path.exists(directory):
        os.makedirs(directory)

    # Error checking
    if 'Solver' not in str(type(solver)):
        py_printf('ERROR', 'Unable to plot the Quadrature from %s rather ' +
                  'than a Solver', str(type(solver)))

    py_printf('NORMAL', 'Plotting the quadrature...')

    # Retrieve data from TrackGenerator
    track_generator = solver.getTrackGenerator()
    polar_quad = solver.getPolarQuad()
    num_azim = track_generator.getNumAzim()
    azim_spacing = track_generator.getTrackSpacing()
    num_polar = polar_quad.getNumPolarAngles()
    phis = np.zeros(num_azim/4)
    thetas = np.zeros(num_polar)

    # Get the polar angles
    for p in range(num_polar):
        thetas[p] = np.arcsin(polar_quad.getSinTheta(p))

    # Get the azimuthal angles
    for a in range(int(num_azim / 4)):
        phis[a] = track_generator.getPhi(a)

    # Make a 3D figure
    fig = plt.figure()
    fig.patch.set_facecolor('none')
    ax = fig.gca(projection ='3d')

    # Plot a wire mesh on one octant of the unit sphere
    u = np.linspace(0, np.pi/2.0, 100)
    v = np.linspace(0, np.pi/2.0, 100)
    x = np.outer(np.cos(u), np.sin(v))
    y = np.outer(np.sin(u), np.sin(v))
    z = np.outer(np.ones(np.size(u)), np.cos(v))
    ax.plot_wireframe(x, y, z, rstride=5, cstride=5, color='k', linewidth=0.1)

    # Plot the quadrature points on the octant unit sphere
    for a in range(int(num_azim / 4)):
        for p in range(num_polar):
            ax.scatter(np.cos(phis[a]) * np.sin(thetas[p]), np.sin(phis[a]) *
                       np.sin(thetas[p]), np.cos(thetas[p]), s=50, color='b')

    # Get the quadrature type
    quad_type = ''
    if polar_quad.getQuadratureType() is openmoc.TABUCHI_YAMAMOTO:
        quad_type = 'TABUCHI_YAMAMOTO'
        title = 'TABUCHI YAMAMOTO'
    elif polar_quad.getQuadratureType() is openmoc.LEONARD:
        quad_type = 'LEONARD'
        title = 'LEONARD'
    elif polar_quad.getQuadratureType() is openmoc.GAUSS_LEGENDRE:
        quad_type = 'GAUSS_LEGENDRE'
        title = 'GAUSS LEGENDRE'
    elif polar_quad.getQuadratureType() is openmoc.EQUAL_WEIGHTS:
        quad_type = 'EQUAL_WEIGHTS'
        title = 'EQUAL WEIGHTS'
    elif polar_quad.getQuadratureType() is openmoc.EQUAL_ANGLES:
        quad_type = 'EQUAL_ANGLES'
        title = 'EQUAL ANGLES'
    elif polar_quad.getQuadratureType() is openmoc.CUSTOM:
        quad_type = 'CUSTOM'
        title = 'CUSTOM'
    else:
        py_printf('ERROR', 'Unable to plot the quadrature since the ' +
                  'quadrature type could not be recognized')

    title += ' with ' + str(num_azim) + ' azim, ' + \
             '{:5.3f}'.format(azim_spacing) + ' spacing and ' \
             + str(num_polar) + ' polar'

    filename = directory + 'quad_' + quad_type + '_' + \
               str(num_azim) + '_azim_' + '{:5.3f}'.format(azim_spacing) + \
               '_cm_spacing_' + str(num_polar) + '_polar.png'

    ax.view_init(elev=30, azim=45)
    ax.set_xlim([0,1])
    ax.set_ylim([0,1])
    ax.set_zlim([0,1])
    plt.title(title)

    # Restore settings if called from ipython
    matplotlib.rcParams.update(curr_rc)

    # Save the figure or return to user
    if get_figure:
        return fig
    else:
        fig.savefig(filename, bbox_inches='tight')
        plt.close(fig)



##
# @class PlotParms plotter.py "openmoc/plotter.py"
# @brief A class to containerize Matplotlib options for 2D spatial plots.
# @details This class is used to containerize plotting options for the general
#          plot_spatial_data(...) routine.
#
class PlotParams(object):

    ##
    # @brief PlotParams class constructor.
    # @details This method initializes a PlotParams object with default values
    #          for 2D Matplotlib image plots.
    #
    def __init__(self):

        ## The Geometry to query when generating the spatial map
        self._geometry = None

        ## The domain type used to map spatial data to the geometry
        self._domain_type = 'fsr'

        ## The filename string
        self._filename = None

        ## The image file extension
        self._extension = '.png'

        ## The image processing library ('matplotlib' or 'pil')
        self._library = 'matplotlib'

        ## The z-coordinate at which to slice the Geometry
        self._zcoord = 0

        ## The number of points along the x- and y-axes
        self._gridsize = 250

        ## A 2-tuple of (maximum, minimum) x-coordinates to display
        self._xlim = None

        ## A 2-tuple of (maximum, minimum) y-coordinates to display
        self._ylim = None

        ## The minor title string
        self._title = None

        ## The minor title string
        self._suptitle = None

        ## Normalize the plotted data to unity
        self._norm = False

        ## Make zeros in the data appear transparent
        self._transparent_zeros = False

        ## Interpolation used between points (e.g., 'nearest')
        self._interpolation = None

        ## Include a colorbar to the right of the plot
        self._colorbar = False

        ## A colormap for the plot
        self._cmap = plt.get_cmap('spectral')

        ## The minimum value used in colormapping the data
        self._vmin = None

        ## The maximum value used in colormapping the data
        self._vmax = None

    @property
    def geometry(self):
        return self._geometry

    @property
    def domain_type(self):
        return self._domain_type

    @property
    def filename(self):
        return self._filename

    @property
    def extension(self):
        return self._extension

    @property
    def library(self):
        return self._library

    @property
    def zcoord(self):
        return self._zcoord

    @property
    def gridsize(self):
        return self._gridsize

    @property
    def xlim(self):
        return self._xlim

    @property
    def ylim(self):
        return self._ylim

    @property
    def colorbar(self):
        return self._colorbar

    @property
    def title(self):
        return self._title

    @property
    def suptitle(self):
        return self._suptitle

    @property
    def norm(self):
        return self._norm

    @property
    def transparent_zeros(self):
        return self._transparent_zeros

    @property
    def interpolation(self):
        return self._interpolation

    @property
    def cmap(self):
        return self._cmap

    @property
    def vmin(self):
        return self._vmin

    @property
    def vmax(self):
        return self._vmax

    @geometry.setter
    def geometry(self, geometry):
        if 'Geometry' not in str(type(geometry)):
            py_printf('ERROR', '%s is not a Geometry object', str(geometry))

        self._geometry = geometry
        self._check_zcoord()

    @domain_type.setter
    def domain_type(self, domain_type):
        if domain_type not in ['material', 'cell', 'fsr']:
            py_printf('ERROR', '%s is not a domain type', str(domain_type))

        self._domain_type = domain_type

    @filename.setter
    def filename(self, filename):
        if not isinstance(filename, str):
            py_printf('ERROR', 'Filename %s is not a string', str(filename))

        self._filename = filename

    @extension.setter
    def extension(self, extension):
        if not isinstance(extension, str):
            py_printf('ERROR', 'Extension %s is not a string', str(extension))

        self._extension = extension

    @library.setter
    def library(self, library):
        if not isinstance(library, str):
            py_printf('ERROR', 'Library %s is not a string', str(library))
        elif library not in ['matplotlib', 'pil']:
            py_printf('ERROR', 'Library %s is not supported', library)

        self._library = library

    @zcoord.setter
    def zcoord(self, zcoord):
        if zcoord:
            self._zcoord = zcoord

        self._check_zcoord()

    @gridsize.setter
    def gridsize(self, gridsize):
        if not is_integer(gridsize):
            py_printf('ERROR', 'Gridsize %s is not an integer', str(gridsize))
        if gridsize <= 0:
            py_printf('ERROR', 'Gridsize %s is negative', str(gridsize))

        self._gridsize = gridsize

    @xlim.setter
    def xlim(self, xlim):
        if xlim:
            if not isinstance(xlim, tuple):
                py_printf('ERROR', 'The xlim %s is not a tuple', str(xlim))
            if len(xlim) != 2:
                py_printf('ERROR', 'The xlim %s is not length 2', str(xlim))

        self._xlim = xlim

    @ylim.setter
    def ylim(self, ylim):
        if ylim:
            if not isinstance(ylim, tuple):
                py_printf('ERROR', 'The ylim %s is not a tuple', str(ylim))
            if len(ylim) != 2:
                py_printf('ERROR', 'The ylim %s is not length 2', str(ylim))

        self._ylim = ylim

    @colorbar.setter
    def colorbar(self, colorbar):
        if colorbar and not isinstance(colorbar, bool):
            py_printf('ERROR', 'Colorbar %s is not a boolean', str(colorbar))

        self._colorbar = colorbar

    @title.setter
    def title(self, title):
        if title and not isinstance(title, str):
            py_printf('ERROR', 'Title %s is not a string', str(title))

        self._title = title

    @suptitle.setter
    def suptitle(self, suptitle):
        if suptitle and not isinstance(suptitle, str):
            py_printf('ERROR', 'Suptitle %s is not a string', str(suptitle))

        self._suptitle = suptitle

    @norm.setter
    def norm(self, norm):
        if norm and not isinstance(norm, bool):
            py_printf('ERROR', 'Norm %s is not a boolean', str(norm))

        self._norm = norm

    @transparent_zeros.setter
    def transparent_zeros(self, transparent_zeros):
        if transparent_zeros and not isinstance(transparent_zeros, bool):
            py_printf('ERROR', 'The transparent_zeros %s is not a ',
                               'boolean', str(transparent_zeros))

        self._transparent_zeros = transparent_zeros

    @interpolation.setter
    def interpolation(self, interpolation):
        if not isinstance(interpolation, str):
            py_printf('ERROR', 'The interpolation %s is not '
                               'a string', str(interpolation))

        self._interpolation = interpolation

    @cmap.setter
    def cmap(self, cmap):
        if cmap and not isinstance(cmap, matplotlib.colors.Colormap):
            py_printf('ERROR', 'The cmap %s is not a Matplotlib',
                               'ColorMap object', str(cmap))

        self._cmap = cmap

    @vmin.setter
    def vmin(self, vmin):
        if vmin and not is_float(vmin) and not is_integer(vmin):
            py_printf('ERROR', 'The vmin %s is not a number', str(vmin))

        self._vmin = vmin

    @vmax.setter
    def vmax(self, vmax):
        if vmax and not is_float(vmax) and not is_integer(vmax):
            py_printf('ERROR', 'The vmin %s is not a number', str(vmax))

        self._vmax = vmax

    def _check_zcoord(self):
        if self.zcoord and self.geometry:
            if not is_float(self.zcoord):
                py_printf('ERROR', 'Unable to produce plot since ' + \
                          'the z-coord %f is not a float', self.zcoord)
            elif self.zcoord < self.geometry.getMinZ() or \
                            self.zcoord > self.geometry.getMaxZ():
                py_printf('ERROR', 'The z-coord %f is outside the ' + \
                          'geometry z-bounds (%f, %f)',
                          self.geometry.getMinZ(), self.geometry.getMaxZ())


##
# @brief This is a helper method to define coordinates for a plotting window.
# @details This routine builds a coordinate surface map for the plotting
#          window defined for by the user. If no window was defined, then
#          this routine uses the outer bounding box around the geometry as
#          the plotting window.
# @param plot_params a PlotParams object initialized with a Geometry
# @return a dictionary with the plotting window map and bounding box
def _get_pixel_coords(plot_params):

    # initialize variables to be returned
    geometry = plot_params.geometry
    bounds = [geometry.getMinX() + TINY_MOVE, geometry.getMaxX() - TINY_MOVE,
              geometry.getMinY() + TINY_MOVE, geometry.getMaxY() - TINY_MOVE]
    coords = dict()

    if not plot_params.xlim is None:
        bounds[0] = plot_params.xlim[0]
        bounds[1] = plot_params.xlim[1]

    if not plot_params.ylim is None:
        bounds[2] = plot_params.ylim[0]
        bounds[3] = plot_params.ylim[1]

    xcoords = np.linspace(bounds[0], bounds[1], plot_params.gridsize)
    ycoords = np.linspace(bounds[2], bounds[3], plot_params.gridsize)

    # add attributes to coords dictionary
    coords['x'] = xcoords
    coords['y'] = ycoords
    coords['bounds'] = bounds

    return coords


##
# @brief Replace unique data values with a random but reproducible color IDs.
# @details Thid method randomly assigns a random integer to each unique value
#          in the input array. This is a helper method for the plotting methods.
# @param data a NumPy array of data to colorize
# @param num_colors the number of random colors to generate
# @param seed the random number seed used to generate colors
# @return A NumPy array with random integer colors
def _colorize(data, num_colors, seed=1):

    # Generate linearly-spaced array of color indices
    all_ids = np.arange(num_colors, dtype=np.int64)

    # Generate linearly-spaced integer color IDs
    id_colors = np.arange(num_colors, dtype=np.int64)

    # Randomly shuffle the linearly-spaced integer color IDs
    numpy.random.seed(seed)
    np.random.shuffle(id_colors)

    # Insert random colors into appropriate locations in data array
    ids_to_colors = np.arange(num_colors, dtype=np.int64)
    ids_to_colors[all_ids] = id_colors

    return ids_to_colors.take(data)


##
# @brief Plot 2D NumPy array data using Python Imaging Library (PIL).
# @details This is a good alternative to matplotlib for high-resolution images.
# @param array a NumPy array of data
# @param plot_params a PlotParams object with the matplotlib colormap to use
# @return A Python Imaging Library (PIL) Image object
def _get_pil_image(array, plot_params):

    from PIL import Image

    # Convert array to a normalized array of floating point values
    float_array = np.zeros(array.shape, dtype=np.float)
    float_array[:,:] = array[:,:]
    float_array[:,:] /= np.max(float_array)

    # Use Python Imaging Library (PIL) to create an image from the array
    return Image.fromarray(np.uint8(plot_params.cmap(float_array) * 255))
